(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{215:function(e,t,o){"use strict";o.r(t);var s=o(19),n=Object(s.a)({},function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("br"),e._v(" "),o("h3",{attrs:{id:"the-problem"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#the-problem","aria-hidden":"true"}},[e._v("#")]),e._v(" "),o("strong",[e._v("The Problem")])]),e._v(" "),o("p",[e._v("The popularity of microservice architecture has enormously increased recently; but this comes with new challenges.")]),e._v(" "),o("p",[e._v("One of these is monitoring. In one of our projects, we used a Kafka connector to intercept changes in our database and write data to a topic. This was a very important component of the system, so we needed to consider its health status carefully.")]),e._v(" "),o("br"),e._v(" "),o("h3",{attrs:{id:"solution"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#solution","aria-hidden":"true"}},[e._v("#")]),e._v(" "),o("strong",[e._v("Solution")])]),e._v(" "),o("p",[e._v("In our first version, we created a Kubernetes’ CronnJob with a simple shell script that checks the status of the connector and, eventually, deletes the failed and restarts it.")]),e._v(" "),o("p",[e._v("This worked quite well; however, this is different from how the other services are health checked with the Kubernetes.")]),e._v(" "),o("p",[e._v("The connector was deployed with Kubernetes; the most natural thing to do is thus using k8s for monitoring pods and eventually restarting it.")]),e._v(" "),o("p",[e._v("The Kafka Connect framework comes with Rest API, and one of these gives you the state of the connectors:")]),e._v(" "),o("p",[e._v("i.e : "),o("a",{attrs:{href:"http://localhost:8083/connectors/connector_name/tasks/taskid/status",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://localhost:8083/connectors/connector_name/tasks/taskid/status"),o("OutboundLink")],1)]),e._v(" "),o("p",[e._v("This seems to resolve our problem... But is it really the case?")]),e._v(" "),o("p",[e._v("Kubernetes health check controls the HTTP status code; the problem is that the Kafka connector API returns 200 HTTP status.")]),e._v(" "),o("p",[e._v("For instance, if the task is failed, the API will return:")]),e._v(" "),o("p",[e._v("HTTP/1.1 200 OK")]),e._v(" "),o("p",[e._v('{"state":"FAILED","id":1,"worker_id":"192.168.86.101:8083"}')]),e._v(" "),o("p",[e._v("In this case, from the Kubernetes point of view, everything is ok.")]),e._v(" "),o("p",[e._v("The solution that worked well for us consisted in adding a sidecar container that takes responsibility for exposing the state of the connector task.")]),e._v(" "),o("p",[e._v("The sidecar pattern allows you to extract some functionality of your application in a different component. For example, we can separate the authentication layer from our “main” component that contains the business logic or - as in our case - extracts the monitoring part.")]),e._v(" "),o("p",[e._v("Our goal is to obtain something like this:")]),e._v(" "),o("p",[o("img",{attrs:{src:"/img/s-1.png",alt:""}})]),e._v(" "),o("p",[e._v("First of all, we created a simple application that takes care of calling the connector API and exposes an API for Kubernetes (we used a simple Python application using Flask - but you can use whatever you want). Something like this:")]),e._v(" "),o("p",[o("img",{attrs:{src:"/img/s-2.png",alt:""}})]),e._v(" "),o("p",[e._v("As you can see, the code is very simple.")]),e._v(" "),o("p",[e._v("The application does two different things: first of all, it exposes an endpoint at “/health” paths that will be called periodically by Kubernetes; secondly, it checks the status of a task and eventually returns an Internal Server Error, in case the HTTP status of the connector was not 200 or if the status was not “RUNNING”.")]),e._v(" "),o("p",[e._v("Now, this application needs to be deployed in the same pods of the connector. This can be done by adding to our deployment.yaml file the container that contains our Python application:")]),e._v(" "),o("p",[o("img",{attrs:{src:"/img/s-3.png",alt:""}})]),e._v(" "),o("br"),e._v(" "),o("h3",{attrs:{id:"conclusions"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#conclusions","aria-hidden":"true"}},[e._v("#")]),e._v(" "),o("strong",[e._v("Conclusions")])]),e._v(" "),o("p",[e._v("The logical result?")]),e._v(" "),o("p",[e._v("Both containers expose the health check of the sidecar, since Kubernetes does not restart the entire pods if one container is up; exposing the same API, the destiny of both containers would be the same.")]),e._v(" "),o("p",[e._v("Once the connector is in FAILED state, Kubernetes will restart the pod.")]),e._v(" "),o("p",[e._v("Some cloud providers may provide a built-in solution for problems like this; but if you can’t use it - for whatever reason - this can be a possible solution.")]),e._v(" "),o("br"),e._v(" "),o("p",[o("em",[e._v("Author: Marco Tosini, Principal Engineer @Bitrock")])])])},[],!1,null,null,null);t.default=n.exports}}]);