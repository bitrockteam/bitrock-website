(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{176:function(e,t,r){e.exports=r.p+"assets/img/scala-italy.b00f6f75.jpg"},204:function(e,t,r){"use strict";r.r(t);var a=r(19),n=Object(a.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("After sponsoring "),a("strong",[e._v("Scala Days 2018 in Berlin")]),e._v(" and "),a("strong",[e._v("Scala Days 2018 in NewYork")]),e._v(", our commitment to supporting "),a("strong",[e._v("Scala language goes on")]),e._v(". "),e._v(" Also this year Bitrock will be sponsor at "),a("strong",[e._v("Scala Italy 2018, the Italian Conference on Scala, taking place in Florence, September 14th-15th")]),e._v(".")]),e._v(" "),a("p",[a("img",{attrs:{src:r(176),alt:"./scala-italy.jpg"}})]),e._v(" "),a("p",[e._v("Scala combines object-oriented and functional programming in one concise, high-level language. Scala's static types help avoid bugs in complex applications, and its JVM and JavaScript runtimes let you build high-performance systems with easy access to huge ecosystems of libraries.")]),e._v(" "),a("p",[e._v("Scala is a pure object-oriented language in the sense that "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/unified-types.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("every value is an object"),a("OutboundLink")],1),e._v(". Types and behavior of objects are described by "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/classes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("classes"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/traits.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("traits"),a("OutboundLink")],1),e._v(". Classes are extended by subclassing and a flexible "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/mixin-class-composition.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("mixin-based composition"),a("OutboundLink")],1),e._v(" mechanism as a clean replacement for multiple inheritance.")]),e._v(" "),a("p",[e._v("Scala is also a functional language in the sense that "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/unified-types.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("every function is a value"),a("OutboundLink")],1),e._v(". Scala provides a "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/basics.html#functions",target:"_blank",rel:"noopener noreferrer"}},[e._v("lightweight syntax"),a("OutboundLink")],1),e._v(" for defining anonymous functions, it supports "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/higher-order-functions.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("higher-order functions"),a("OutboundLink")],1),e._v(", it allows functions to be "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/nested-functions.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("nested"),a("OutboundLink")],1),e._v(", and supports "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/multiple-parameter-lists.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("currying"),a("OutboundLink")],1),e._v(". Scala’s "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/case-classes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("case classes"),a("OutboundLink")],1),e._v(" and its built-in support for "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/pattern-matching.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("pattern matching"),a("OutboundLink")],1),e._v(" model algebraic types used in many functional programming languages. "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/singleton-objects.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Singleton objects"),a("OutboundLink")],1),e._v(" provide a convenient way to group functions that aren’t members of a class.")]),e._v(" "),a("p",[e._v("Furthermore, Scala’s notion of pattern matching naturally extends to the "),a("a",{attrs:{href:"https://github.com/scala/scala-xml/wiki/XML-Processing",target:"_blank",rel:"noopener noreferrer"}},[e._v("processing of XML data"),a("OutboundLink")],1),e._v(" with the help of "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/regular-expression-patterns.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("right-ignoring sequence patterns"),a("OutboundLink")],1),e._v(", by way of general extension via "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/extractor-objects.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("extractor objects"),a("OutboundLink")],1),e._v(". In this context, "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/for-comprehensions.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("for comprehensions"),a("OutboundLink")],1),e._v(" are useful for formulating queries. These features make Scala ideal for developing applications like web services.")]),e._v(" "),a("p",[e._v("Scala is equipped with an expressive type system that enforces statically that abstractions are used in a safe and coherent manner. In particular, the type system supports:")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://docs.scala-lang.org/tour/generic-classes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("generic classes"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://docs.scala-lang.org/tour/variances.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("variance annotations"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://docs.scala-lang.org/tour/upper-type-bounds.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("upper"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/lower-type-bounds.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("lower"),a("OutboundLink")],1),e._v(" type bounds,")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://docs.scala-lang.org/tour/inner-classes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("inner classes"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/abstract-types.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("abstract types"),a("OutboundLink")],1),e._v(" as object members")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://docs.scala-lang.org/tour/compound-types.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("compound types"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://docs.scala-lang.org/tour/self-types.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("explicitly typed self references"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://docs.scala-lang.org/tour/implicit-parameters.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("implicit parameters"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/implicit-conversions.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("conversions"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://docs.scala-lang.org/tour/polymorphic-methods.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("polymorphic methods"),a("OutboundLink")],1)])]),e._v(" "),a("p",[a("a",{attrs:{href:"https://docs.scala-lang.org/tour/type-inference.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Type inference"),a("OutboundLink")],1),e._v(" means the user is not required to annotate code with redundant type information. In combination, these features provide a powerful basis for the safe reuse of programming abstractions and for the type-safe extension of software.")]),e._v(" "),a("p",[e._v("In practice, the development of domain-specific applications often requires domain-specific language extensions. Scala provides a unique combination of language mechanisms that make it easy to smoothly add new language constructs in the form of libraries.")]),e._v(" "),a("p",[e._v("In many cases, this can be done without using meta-programming facilities such as macros. For example,")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"http://docs.scala-lang.org/overviews/core/implicit-classes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Implicit classes"),a("OutboundLink")],1),e._v(" allow adding extension methods to existing types.")]),e._v(" "),a("li",[a("a",{attrs:{href:"https://docs.scala-lang.org/overviews/core/string-interpolation.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("String interpolation"),a("OutboundLink")],1),e._v(" is user-extensible with custom interpolators.")])]),e._v(" "),a("p",[e._v("Scala is designed to interoperate well with the popular Java Runtime Environment (JRE). In particular, the interaction with the mainstream object-oriented Java programming language is as smooth as possible. Newer Java features like SAMs, "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/higher-order-functions.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("lambdas"),a("OutboundLink")],1),e._v(", "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/annotations.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("annotations"),a("OutboundLink")],1),e._v(", and "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/generic-classes.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("generics"),a("OutboundLink")],1),e._v(" have direct analogues in Scala.")]),e._v(" "),a("p",[e._v("Those Scala features without Java analogues, such as "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/default-parameter-values.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("default"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"https://docs.scala-lang.org/tour/named-arguments.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("named parameters"),a("OutboundLink")],1),e._v(", compile as close to Java as they can reasonably come. Scala has the same compilation model (separate compilation, dynamic class loading) like Java and allows access to thousands of existing high-quality libraries.")])])},[],!1,null,null,null);t.default=n.exports}}]);