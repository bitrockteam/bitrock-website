(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{211:function(e,t,a){"use strict";a.r(t);var o=a(19),i=Object(o.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("p",[e._v("When approaching the React world, using Redux or MobX as state management is almost automatic. Or, in any case, the libraries change, but the basic architecture doesn’t: it is always something similar to the Redux Pattern with reducers, actions, selector, middleware, etc.")]),e._v(" "),a("p",[e._v("But is there the possibility of using a different architecture? Something with RxJs as with Angular? By doing some research, it seems so. Let's see more in detail what we are talking about.")]),e._v(" "),a("p",[e._v("First of all, we need to think outside the classic pull-based pattern and move to something new for those coming from the React world: a push-based architecture.")]),e._v(" "),a("p",[e._v("With data-push architectures, view components simply react to asynchronous data change notifications and render the current data values.")]),e._v(" "),a("p",[e._v("The library that allows us to manage the store in this way is "),a("a",{attrs:{href:"https://github.com/datorama/akita",target:"_blank",rel:"noopener noreferrer"}},[e._v("Akita"),a("OutboundLink")],1),e._v(":")]),e._v(" "),a("p",[a("em",[e._v("“Akita is a state management pattern, built on top of RxJS, which takes the idea of multiple data stores from Flux and the immutable updates from Redux, along with the concept of streaming data, to create the Observable Data Stores model.")]),e._v("”")]),e._v(" "),a("p",[e._v("So basically, Akita enables us to easily build reactive, "),a("em",[e._v("asynchronous")]),e._v(", data-push solutions for our state management needs.")]),e._v(" "),a("p",[e._v("Another important concept to add is the one related to the Facades. "),a("strong",[e._v("Facades")]),e._v(" are a programming pattern in which a simpler public interface is provided to mask a composition of internal, more-complex, component usages.")]),e._v(" "),a("p",[e._v("In order to build our application, we rely on RxJS and React Hooks; nothing else is needed.")]),e._v(" "),a("p",[e._v("Let's now consider a very simple example built on the ideas found in some articles.")]),e._v(" "),a("p",[e._v("In our case we need to have a list of users and to be able to interface through the classic CRUD functions.")]),e._v(" "),a("p",[e._v('Starting from the well-known create-react-app with the addition of TypeScript, we create a folder that will contain our entities; in this case, it will only have a "user" folder as a child.')]),e._v(" "),a("p",[e._v('Inside, we define a simple interface of our "user" entity in the model.ts file:')]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/u-1.png",alt:""}})]),e._v(" "),a("p",[e._v('Let\'s now start by initializing the store of our entity, creating a "UsersState" interface and then creating a "UsersStore" store by extending the Akita store, and finally exporting it:')]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/u-2.png",alt:""}})]),e._v(" "),a("p",[e._v("At this point, we can create services to manipulate the store, also relying on the methods that an Akita store provides.")]),e._v(" "),a("p",[e._v("This is where we can use all our knowledge of RxJS in order to be able to create more complex flows to act on the store.")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/u-3.png",alt:""}}),a("br"),e._v('\nFinally, through the "QueryEntity", we can take the whole store - or just a filtered part - and channel it into an observable stream of RxJS.')]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/u-4.png",alt:""}})]),e._v(" "),a("p",[e._v("Last but not least, the creation of a custom Hooks that will internally manage all issues regarding RxJS, Facades, and Akita.")]),e._v(" "),a("p",[e._v('First, we map and expose the services of our "userService", in this case all.Then, we create the internal state of our custom hook. Finally, we need to build the selectors for `users` and `active` state changes and manage subscriptions with auto-cleanup.')]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/u-5.png",alt:""}})]),e._v(" "),a("p",[e._v("Now our user entity should have everything needed. We import our custom Hooks, and that's it.")]),e._v(" "),a("p",[e._v("To play a little bit, let’s divide the application into several components in order to test it. The result? Well, it works!")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/u-6.png",alt:""}})]),e._v(" "),a("p",[e._v("And here’s the child component:")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/u-7.png",alt:""}})]),e._v(" "),a("p",[e._v("Here’s how the application works in the browser:")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/gif.gif",alt:""}})]),e._v(" "),a("h3",{attrs:{id:"conclusions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conclusions","aria-hidden":"true"}},[e._v("#")]),e._v(" "),a("strong",[e._v("Conclusions")])]),e._v(" "),a("p",[e._v("Although this example is quite simple, the outcomes are pretty surprising. It was really easy - and also quite logical - to connect all the pieces to compose the state management and, as we have seen, no configurations (of any kind) were needed.")]),e._v(" "),a("p",[e._v("For those approaching an architecture like this for the first time, the greatest difficulty is certainly represented by RxJS. To write simple services or queries, it may be enough to know the basics of RxJS; however, in case of large applications with complex services, a good knowledge of technology makes a huge (positive difference), really giving an edge. Furthermore, you need to be very careful where and how you use all the various facades in your application. Being in a push pattern, any change of state triggers the React lifecycle in every component that uses our hooks; watching and controlling performance is thus very important.")]),e._v(" "),a("p",[e._v("Obviously, this is just the beginning: there is a world of things to say about Akita, RxJS, push-patterns etc, and it would take much more than one simple article to explore all of them.")]),e._v(" "),a("p",[e._v('The aim of this contribution was to give you just a little idea of this "new" architecture for state management with React. I hope I’ve hit the target.')]),e._v(" "),a("p",[a("br"),a("br")]),e._v(" "),a("p",[a("em",[e._v("Author: Mattia Ripamonti, UX/UI Engineer @Bitrock")])]),e._v(" "),a("p",[a("br"),a("br")]),e._v(" "),a("p",[e._v("Useful Resources:")]),e._v(" "),a("p",[e._v("1 - "),a("a",{attrs:{href:"https://medium.com/@thomasburlesonIA/react-facade-best-practices-1c8186d8495a",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Facade Best Practices"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("2 - "),a("a",{attrs:{href:"https://medium.com/@thomasburlesonIA/https-medium-com-thomasburlesonia-react-hooks-rxjs-facades-4e116330bbe1",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Hooks RxJs Facades"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("3 - "),a("a",{attrs:{href:"https://medium.com/@thomasburlesonIA/push-based-architectures-with-rxjs-81b327d7c32d",target:"_blank",rel:"noopener noreferrer"}},[e._v("Push Based Architectures with RxJs"),a("OutboundLink")],1)]),e._v(" "),a("p",[e._v("4 - "),a("a",{attrs:{href:"https://engineering.datorama.com/oop-and-rxjs-managing-state-in-react-with-akita-de981e09307",target:"_blank",rel:"noopener noreferrer"}},[e._v("Managing State in React with Akita"),a("OutboundLink")],1)])])},[],!1,null,null,null);t.default=i.exports}}]);