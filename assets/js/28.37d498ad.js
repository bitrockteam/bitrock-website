(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{209:function(e,t,a){"use strict";a.r(t);var i=a(19),o=Object(i.a)({},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h4",{attrs:{id:"introduction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction","aria-hidden":"true"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),a("p",[e._v("The hexagonal architecture (also called “ports and adapters”) is an architectural pattern used in software design designed in 2005 by Alistair Cockburn.")]),e._v(" "),a("p",[e._v("The hexagonal architecture is allegedly at the origin of the "),a("strong",[e._v("microservices architecture")]),e._v(".")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_1.png",alt:""}})]),e._v(" "),a("br"),e._v(" "),a("h4",{attrs:{id:"what-it-brings-to-the-table"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-it-brings-to-the-table","aria-hidden":"true"}},[e._v("#")]),e._v(" What it Brings to the Table")]),e._v(" "),a("p",[e._v("The most used service architecture is "),a("strong",[e._v("layered")]),e._v(". Often, this type of architecture leads to dependencies of business logic from external contract (e.g., database, external service, and so on). This brings stiffness and coupling to the system, forcing us to recompile classes that contain the business logic whenever an API changes.")]),e._v(" "),a("br"),e._v(" "),a("h5",{attrs:{id:"loose-coupling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#loose-coupling","aria-hidden":"true"}},[e._v("#")]),e._v(" Loose coupling")]),e._v(" "),a("p",[e._v("In the hexagonal architecture, components communicate with each other using a number of exposed ports, which are simple interfaces. This is an application of the "),a("strong",[e._v("Dependency Inversion Principle")]),e._v(" (the “D” in SOLID).")]),e._v(" "),a("br"),e._v(" "),a("h5",{attrs:{id:"exchangeable-components"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#exchangeable-components","aria-hidden":"true"}},[e._v("#")]),e._v(" Exchangeable components")]),e._v(" "),a("p",[e._v("An adapter is a software component that allows a technology to interact with a port of the hexagon. Adapters make it easy to exchange a certain layer of the application without impacting business logic. This is a core concept of "),a("strong",[e._v("evolutionary architectures")]),e._v(".")]),e._v(" "),a("br"),e._v(" "),a("h5",{attrs:{id:"maximum-isolation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#maximum-isolation","aria-hidden":"true"}},[e._v("#")]),e._v(" Maximum isolation")]),e._v(" "),a("p",[e._v("Components can be tested in isolation from the outside environment or you can use dependency injection and other techniques (e.g., mocks, stubs) to enable easier testing.")]),e._v(" "),a("p",[a("strong",[e._v("Contract testing")]),e._v(" supersedes integration testing for a faster and easier development flow.")]),e._v(" "),a("br"),e._v(" "),a("h5",{attrs:{id:"the-domain-at-the-center"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-domain-at-the-center","aria-hidden":"true"}},[e._v("#")]),e._v(" The domain at the center")]),e._v(" "),a("p",[e._v("Domain objects can contain both state and behavior. The closer the behavior is to the state, the easier the code will be to understand, reason about, and maintain.")]),e._v(" "),a("p",[e._v("Since domain objects have no dependencies on other layers of the application, changes in other layers don’t affect them. This is a prime example of the "),a("strong",[e._v("Single Responsibility Principle")]),e._v(" (the “S” in “SOLID”).")]),e._v(" "),a("br"),e._v(" "),a("h4",{attrs:{id:"how-to-implement-it"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-to-implement-it","aria-hidden":"true"}},[e._v("#")]),e._v(" How to Implement it")]),e._v(" "),a("p",[e._v("Let's now have a look on what it means to build a project following the hexagonal architecture to better understand the difference and its benefit in comparison with a more common plain layered architecture.")]),e._v(" "),a("br"),e._v(" "),a("h5",{attrs:{id:"project-layout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#project-layout","aria-hidden":"true"}},[e._v("#")]),e._v(" Project layout")]),e._v(" "),a("p",[e._v("In a layered architecture project, the package structure usually looks like the following:")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_2.png",alt:""}}),a("br"),e._v("\nHere we can find a package for each application layer:")]),e._v(" "),a("ul",[a("li",[e._v("the one responsible for exposing the service for external communication (e.g., REST APIs);")]),e._v(" "),a("li",[e._v("the one where the core business logic is defined;")]),e._v(" "),a("li",[e._v("the one with all the database integration code;")]),e._v(" "),a("li",[e._v("the one responsible for communicating with other external services;")]),e._v(" "),a("li",[e._v("and more...")])]),e._v(" "),a("br"),e._v(" "),a("h5",{attrs:{id:"layers-coupling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#layers-coupling","aria-hidden":"true"}},[e._v("#")]),e._v(" Layers Coupling")]),e._v(" "),a("p",[e._v("At first glance, this could look like a nice and clean solution to keep the different pieces of the application separated and well organized, but, if we dive a bit deeper into the code, we can find some code smells that should alert us.")]),e._v(" "),a("p",[e._v("In fact, after a quick inspection of the core business logic of the application, we immediately find something definitely in contrast with our idea of clean and well defined separation of the various components. The business logic that we'd like to keep isolated from all the external layers clearly references some dependencies from the database and the external service package.")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_3.png",alt:""}})]),e._v(" "),a("p",[e._v("These dependencies imply that in case of changes in the database code or in the external service communication, we'll need to "),a("strong",[e._v("recompile the main logic")]),e._v(" and probably change and adapt it, in order to make it compatible with the new database and external service versions. This means that we need to spend time on this new integration, test it properly and, during this process, we expose ourselves to the introduction of some bugs.")]),e._v(" "),a("br"),e._v(" "),a("h5",{attrs:{id:"interfaces-to-the-rescue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interfaces-to-the-rescue","aria-hidden":"true"}},[e._v("#")]),e._v(" Interfaces to the Rescue")]),e._v(" "),a("p",[e._v("This is where the hexagonal architecture really shines and helps us avoid all of this. First we need to "),a("strong",[e._v("decouple")]),e._v(" the business logic from its database dependencies: this can be easily achieved with the introduction of a simple "),a("strong",[e._v("interface")]),e._v(" (also called “port”) that will define the behavior that a certain database class needs to implement to be compatible with our main logic.")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_4.png",alt:""}})]),e._v(" "),a("p",[e._v("Then we can use this contract in the actual database implementation to be sure that it's compliant with the defined behavior.")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_5.png",alt:""}})]),e._v(" "),a("p",[e._v("Now we can come back to our main logic class and, thanks to the changes described above, we can finally get rid of the database dependency and have the business logic "),a("strong",[e._v("completely decoupled")]),e._v(" from the persistence details.")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_6.png",alt:""}})]),e._v(" "),a("p",[e._v("It's important to note that the new interface we introduced is defined inside the business logic package and, therefore, it’s part of it and not of the database layer. This trick allows us to apply the "),a("strong",[e._v("Dependency Inversion Principle")]),e._v(" and keep our application core pure and isolated from all the external details.")]),e._v(" "),a("p",[e._v("We can then apply the same approach to the external service dependency and finally clear the whole logic class of all its dependencies from the other layer of the application.")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_7.png",alt:""}})]),e._v(" "),a("br"),e._v(" "),a("h5",{attrs:{id:"dto-for-model-abstraction"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dto-for-model-abstraction","aria-hidden":"true"}},[e._v("#")]),e._v(" DTO for model abstraction")]),e._v(" "),a("p",[e._v("This already give us a nice level of separation, but there is still room for improvement. In fact if you look at the definition of the Database class you will notice that we are using the same model from our main logic to operate on the persistence layer. While this is not a problem for the isolation of our core logic, it could be a good idea to create a separate model for the persistence layer, so that if we need to make some changes in the structure of the table, for example, we are not forced to propagate the changes also to the business logic layer. This can be achieved with the introduction of a "),a("strong",[e._v("DTO")]),e._v(" (Data transfer object).")]),e._v(" "),a("p",[e._v("A DTO is nothing more that a new external model with pair of mapping function that allow us to transform our internal business model to the external one and the other way around. First of all, we need to define the new private model for our database and external service layers.")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_8.png",alt:""}})]),e._v(" "),a("p",[e._v("Then we need to create a proper function to transform this new database model into the internal business logic model (and vice versa based on the application needs).")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_9.png",alt:""}})]),e._v(" "),a("p",[e._v("Now we can finally change the Database class to work with the newly introduced model and transform it into the logic one when it communicates with the business logic layer.")]),e._v(" "),a("p",[a("img",{attrs:{src:"/img/s_10.png",alt:""}})]),e._v(" "),a("p",[e._v("This approach works very well to protect our logic from external interference, but it has some consequence. The main one is an explosion of the number of the models, when most of the time the models are the same; the other one is that the logic about transforming models can be tedious and always need to be properly tested to avoid errors. One compromise that we can take is starting only with the business models (defining them in the correct package) and introduce the external models only when the two models diverge.")]),e._v(" "),a("br"),e._v(" "),a("h4",{attrs:{id:"when-to-embrace-it"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#when-to-embrace-it","aria-hidden":"true"}},[e._v("#")]),e._v(" When to embrace it")]),e._v(" "),a("p",[e._v("Hexagonal architecture is no silver bullet. If you’re building an application with rich business rules that can be expressed in a rich domain model that combines state with behavior, then this architecture really shines because it puts the domain model in the center.")]),e._v(" "),a("p",[e._v("Combine it with microservices architecture and you’ll get a "),a("strong",[e._v("future-proof evolutionary architecture")]),e._v(".")])])},[],!1,null,null,null);t.default=o.exports}}]);